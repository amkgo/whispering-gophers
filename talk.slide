Whispering Gophers
Network programming in Go

Andrew Gerrand

Francesc Campoy


* Introduction

This code lab demonstrates network programming with Go.

The final goal is to build a "whispernet": a peer to peer mesh network for transmitting text messages.

The codelab comprises five exercises of increasing complexity.

This is not an introducion to the Go Programming Language; some experience writing Go code is required.


* Vital resources

Visit

.link http://code.google.com/p/whispering-gophers

for code samples and links to these slides.

Then install the utility library:

	go get code.google.com/p/whispering-gophers/util

(You must have [[http://mercurial.selenic.com/][Mercurial]] installed for "go get" to work.)


* Exercise 1: Reading and encoding messages

Write a program that

- reads lines from standard input (`os.Stdin`)
- encodes each line as a JSON object, written to standard output (`os.Stdout`)

This line of input:

	Hello, world

should produce this output:

	{"Body":"Hello, world"}

This is our system's basic message format.

.image talk/img/ex1.png


* Readers and Writers

The `io` package provides fundamental I/O interfaces that are used throughout most Go code.

The most ubiquitous are the `Reader` and `Writer` types, which describe streams of data.

.code talk/code/io/io.go

`Reader` and `Writer` implementations include files, sockets, (de)compressors, image and JSON codecs, and many more.


* Chaining Readers

.play talk/code/reader.go


* Buffered I/O

The `bufio` package implements buffered I/O. Its `bufio.Reader` and `bufio.Writer` types wrap `io.Reader` and `io.Writer`, providing buffering and also some help for textual I/O.

.play talk/code/bufio.go /const/,$

# TODO(adg): use Scanner once Go 1.1 is out


* Encoding JSON objects

The `encoding/json` package converts JSON-encoded data to and from native Go data structures.

.play talk/code/json-encode.go /type/,$


* Error checking

Many functions in Go return an `error` value.
These values are your friends; they will tell you where you went wrong.
Ignore them at your peril!

Use [[http://golang.org/pkg/log/#Println][`log.Println`]] to print log messages, and [[http://golang.org/pkg/log/#Fatal][`log.Fatal`]] to print a message and exit the program printing a stack trace.

.play talk/code/log.go /func main/,$


* Exercise 1: Reading and encoding messages (recap)

Write a program that

- reads lines from standard input (`os.Stdin`)
- encode each line as a JSON object, written to standard output (`os.Stdout`)

This line of input:

	Hello, world

should produce this output:

	{"Body":"Hello, world"}

See:

- [[http://golang.org/pkg/bufio/#Reader][`bufio.Reader`]] (use `ReadString`, *not* `ReadLine`)
- [[http://golang.org/pkg/encoding/json/#Encoder][`encoding/json.Encoder`]]

# TOOD(adg): switch to bufio.Scanner post go1.1


* Exercise 2: Send messages to a peer

Extend your program:

- make a TCP connection to a remote host
- write the JSON-encoded messages to the connnection instead of standard output

.image talk/img/ex2.png 300 800


* Making a network connection

The `net` package provides talk/code for network operations.

The [[http://golang.org/pkg/net/#Dial][`net.Dial`]] function opens a nework connection and returns a [[http://golang.org/pkg/net/#Conn][`net.Conn`]], which implements `io.Reader`, `io.Writer`, and `io.Closer` (or `io.ReadWriteCloser`).

.play talk/code/dial.go /func main/,$

(Usually you would use the `net/http` package to make an HTTP request; the purpose of this example is to demonstrate the lower-level `net` package.)


* Exercise 2: Send messages to a peer (recap)

Extend your program:

- make a TCP connection to a remote host
- write the JSON-encoded messages to the connnection instead of standard output

See:

- [[http://golang.org/pkg/net/#Dial][`net.Dial`]]

For testing, we have provided a simple server that accepts connections and logs everything it receives. Install and run it like so:

	$ go get code.google.com/p/whispering-gophers/util/server
	$ server -addr=localhost:8000

Then have your program connect to `localhost:8000`.


* Exercise 3: Accept peer connections

- listen on a TCP port,
- accept incoming connections and launch a goroutine to handle each one,
- decode JSON messages from the incoming connections,
- print each message `Body` to standard output.

After listening, announce yourself to the master peer:

- add an `Addr` field to the message struct,
- connect to a master peer (address provided by your instructor), and
- send a message containing your listen address. For example:

	{"Addr": "192.168.20.50:23451"}

.image talk/img/ex3.png


* Listening, accepting, and serving (1/2)

The [[http://golang.org/pkg/net/#Listen][`net.Listen`]] function binds to a socket and returns a [[http://golang.org/pkg/net/#Listener][`net.Listener`]].
The [[http://golang.org/pkg/net/#Listener][`net.Listener`]] provides an `Accept` method that blocks until a client connects to the socket, and then returns a [[http://golang.org/pkg/net/#Conn][`net.Conn`]].

This server reads data from a connection and echoes it back:

.play talk/code/listen-single.go /func main/,$


* Goroutines

Goroutines are lightweight threads that are managed by the Go runtime. To run a function in a new goroutine, just put `"go"` before the function call.

.play talk/code/goroutines.go


* Listening, accepting, and serving (2/2)

To handle requests concurrently, serve each connection in its own goroutine:

.play talk/code/listen.go /func main/,$


* Obtaining the listener address (1/2)

The `net.Listener` interface provides an `Addr` method that returns a `net.Addr`. 

.play talk/code/listen-addr.go /import/,$

When listening on all interfaces, as specified by the empty hostname in the string `":4000"` above, the `net.Addr` won't be that of our public IP address.

To complete our program, we need to find that IP.


* Obtaining the listener address (2/2)

The [[http://godoc.org/code.google.com/a/whisper/][`"code.google.com/a/whisper"`]] package provides a `Listen` function that binds to a random port on the first available public interface.

.play talk/code/listen-addr-util.go /import/,$


* Decoding JSON objects

Decoding JSON from an `io.Reader` is just like writing them to an `io.Writer`, but in reverse.

.play talk/code/json-decode.go /type/,$


* Exercise 3: Accept peer connections (recap)

- listen on a TCP port,
- accept incoming connections and launch a goroutine to handle each one,
- decode JSON messages from the incoming connections,
- print each message `Body` to standard output.

After listening, announce yourself to the master peer:

- add an `Addr` field to the message struct,
- connect to a master peer (address provided by your instructor), and
- send a message containing your listen address. For example:

	{"Addr": "192.168.20.50:23451"}

Hints:

- import [[http://godoc.org/code.google.com/a/whisper/util][`"code.google.com/a/whisper/util"`]] and use its `Listen` and `RegisterPeer` functions
- read about [[http://golang.org/pkg/net/#Listener][`net.Listener`]], and get the listen address using its `Addr` method
- [[http://golang.org/pkg/encoding/json/#Decoder][`encoding/json.Decoder`]] and the `fmt` package

# TODO: master peer that periodically sends funny messages to the client


* Exercise 4: Sending and receiving

Combining the code from the two previous exercises:

- for each received message, check its Addr field for a new peer address,
- connect to each new peer you find,
- send messages entered at standard input to all connected peers.

.image talk/img/ex4.png


* Channels

Goroutines communicate via channels. A channel is a typed conduit that may be synchronous (unbuffered) or asynchronous (buffered).

.play talk/code/chan.go


* Distributing messages

.play talk/code/fanout.go /func/,$


* Protecting shared state

Mutexes are a simple means to protect shared state from concurrent access.

.play talk/code/lock.go /START/,/END/


* Exercise 4: Broadcast messages to many peers (recap)

Combining the code from the two previous exercises:

- for each received message, check its Addr field for a new peer address,
- connect to each new peer you find,
- send messages entered at standard input to all connected peers.

Hints:

- separate the input handling from the message encoding
- each peer should have a goroutine that receives messages from a channel and sends them to the peer as JSON objects
- use a global map of type `map[string]chan`Message` to track connected peers

.image talk/img/ex4.png


* Exercise 5: Re-broadcast received messages

Extend your program:

- add `ID` and `TTL` fields to the message object,
- send new messages with a random ID and a fixed Time To Live (eg, 5),
- re-send any received messages to all connected peers,
- record the ID of each incoming message,
- don't re-send messages you have already seen.

The new message format:

	{"Body": "Hello, world", "TTL": 5, "ID": "c8e2f561"}

Hints:

- use [[http://godoc.org/code.google.com/a/whisper/#RandomID][`util.RandomID`]] to generate random IDs
- use a global map of type `map[string]bool` to track seen message IDs
